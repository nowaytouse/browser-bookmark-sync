//! Cookie data type and extraction
//!
//! Supports Chromium and Firefox browsers.

use crate::crypto;
use anyhow::Result;
use rusqlite::Connection;
use serde::{Deserialize, Serialize};
use std::path::Path;

/// Cookie entry from browser
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Cookie {
    pub host: String,
    pub name: String,
    pub value: String,
    pub path: String,
    pub expires: i64,
    pub is_secure: bool,
    pub is_http_only: bool,
    pub browser: String,
}

/// Extract cookies from Chromium-based browser
pub fn extract_chromium_cookies(db_path: &Path, browser: &str) -> Result<Vec<Cookie>> {
    let master_key = crypto::get_chromium_master_key(browser)?;
    let conn = Connection::open(db_path)?;
    
    let mut stmt = conn.prepare(
        "SELECT host_key, name, encrypted_value, path, expires_utc, is_secure, is_httponly 
         FROM cookies"
    )?;
    
    let mut cookies = Vec::new();
    
    let rows = stmt.query_map([], |row| {
        Ok((
            row.get::<_, String>(0)?,
            row.get::<_, String>(1)?,
            row.get::<_, Vec<u8>>(2)?,
            row.get::<_, String>(3)?,
            row.get::<_, i64>(4)?,
            row.get::<_, i32>(5)?,
            row.get::<_, i32>(6)?,
        ))
    })?;
    
    for row in rows {
        let (host, name, encrypted_value, path, expires, is_secure, is_http_only) = row?;
        
        let value = if crypto::is_encrypted(&encrypted_value) {
            crypto::decrypt_chromium_data(&master_key, &encrypted_value)
                .unwrap_or_else(|_| "[decryption failed]".to_string())
        } else {
            String::from_utf8_lossy(&encrypted_value).to_string()
        };
        
        cookies.push(Cookie {
            host,
            name,
            value,
            path,
            expires,
            is_secure: is_secure != 0,
            is_http_only: is_http_only != 0,
            browser: browser.to_string(),
        });
    }
    
    Ok(cookies)
}

/// Extract cookies from Firefox
pub fn extract_firefox_cookies(db_path: &Path) -> Result<Vec<Cookie>> {
    let conn = Connection::open(db_path)?;
    
    let mut stmt = conn.prepare(
        "SELECT host, name, value, path, expiry, isSecure, isHttpOnly 
         FROM moz_cookies"
    )?;
    
    let mut cookies = Vec::new();
    
    let rows = stmt.query_map([], |row| {
        Ok((
            row.get::<_, String>(0)?,
            row.get::<_, String>(1)?,
            row.get::<_, String>(2)?,
            row.get::<_, String>(3)?,
            row.get::<_, i64>(4)?,
            row.get::<_, i32>(5)?,
            row.get::<_, i32>(6)?,
        ))
    })?;
    
    for row in rows {
        let (host, name, value, path, expires, is_secure, is_http_only) = row?;
        
        cookies.push(Cookie {
            host,
            name,
            value,
            path,
            expires,
            is_secure: is_secure != 0,
            is_http_only: is_http_only != 0,
            browser: "Firefox".to_string(),
        });
    }
    
    Ok(cookies)
}

/// Export cookies to Netscape format (for curl)
pub fn export_to_netscape(cookies: &[Cookie], output_path: &Path) -> Result<()> {
    use std::io::Write;
    
    let mut file = std::fs::File::create(output_path)?;
    
    writeln!(file, "# Netscape HTTP Cookie File")?;
    writeln!(file, "# https://curl.haxx.se/docs/http-cookies.html")?;
    writeln!(file, "# This file was generated by browser-sync\n")?;
    
    for cookie in cookies {
        let domain_flag = if cookie.host.starts_with('.') { "TRUE" } else { "FALSE" };
        let secure_flag = if cookie.is_secure { "TRUE" } else { "FALSE" };
        
        writeln!(
            file,
            "{}\t{}\t{}\t{}\t{}\t{}\t{}",
            cookie.host,
            domain_flag,
            cookie.path,
            secure_flag,
            cookie.expires,
            cookie.name,
            cookie.value
        )?;
    }
    
    Ok(())
}

/// Export cookies to JSON format
pub fn export_to_json(cookies: &[Cookie], output_path: &Path) -> Result<()> {
    let json = serde_json::to_string_pretty(cookies)?;
    std::fs::write(output_path, json)?;
    Ok(())
}
